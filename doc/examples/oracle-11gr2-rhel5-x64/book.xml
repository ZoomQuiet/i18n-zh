<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../../../lib/docbook/docbook4/docbookx.dtd">
<!--<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.5//EN'
        'http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd'>-->
<article lang="en">
  <articleinfo>
    <title>Install Oracle 11g R2 within RHEL 5.4 x64</title>
    <pubdate>2009-10-09</pubdate>
    <copyright>
      <year>2009</year>
      <holder>Elephant Talk Communications, Inc.</holder>
    </copyright>
    <authorgroup>
      <author>
        <personname>Cauchy Song</personname>
        <email>cauchy.song@elephanttalk.com</email>
      </author>
    </authorgroup>
    <revhistory>
      <revision>
        <revnumber>1.1</revnumber>
        <date>2009-10-09</date>
        <authorinitials>Cauchy Song</authorinitials>
        <revremark>Add physical standby database</revremark>
      </revision>
      <revision>
        <revnumber>1.0</revnumber>
        <date>2009-9-30</date>
        <authorinitials>Cauchy Song</authorinitials>
        <revremark>First revision</revremark>
      </revision>
    </revhistory>
  </articleinfo>

  <section>
    <title>Install RHEL 5.4 x64</title>
      <section>
        <title>Pre Install</title>
        <para>x64 machine with 1G memory and 16G disk. Oracle require at least <emphasis>1G useable memory</emphasis>, so you need extra memory about 24M.</para>
        <para>RHEL 5.4 x64 install image: rhel-server-5.4-x86_64-dvd.iso (3.4 GB).</para>
      </section>

      <section>
        <title>Install RHEL 5.4 x64</title>
        <para>Please use LVM as far as possible for easy expand filesystem space, and select 'Software Development' for install oracle.</para>
      </section>

      <section>
        <title>Post Install</title>
          <section>
            <title>Check missing packages</title>
            <para>Check <ulink url="http://download.oracle.com/docs/cd/E11882_01/install.112/e10860/toc.htm#BHCGJCEA">
              <citetitle>Package Requirements</citetitle></ulink>, install missing packages like this:</para>
            <screen>rpm -ivh sysstat-7.0.2-3.el5.x86_64.rpm

rpm -ivh libaio-devel-0.3.106-3.2.i386.rpm
rpm -ivh libaio-devel-0.3.106-3.2.x86_64.rpm

rpm -ivh unixODBC-devel-2.2.11-7.1.i386.rpm unixODBC-2.2.11-7.1.i386.rpm
rpm -ivh unixODBC-devel-2.2.11-7.1.x86_64.rpm unixODBC-2.2.11-7.1.x86_64.rpm</screen>
          </section>

          <section>
            <title>Set hostname</title>
            <para>Edit <filename>/etc/sysconfig/network</filename>, set <emphasis>HOSTNAME</emphasis> to <replaceable>x64-ORA-01</replaceable>.</para>
          </section>

          <section>
            <title>Set domainname</title>
            <para>Edit <filename>/etc/sysctl.conf</filename>, set <emphasis>kernel.domainname</emphasis> to <replaceable>songdongsheng.info</replaceable>.</para>
          </section>

          <section>
            <title>Update hosts</title>
            <para>Edit <filename>/etc/hosts</filename>, you should update to fit your machine.</para>
            <screen>192.168.30.126 x64-ORA-01.songdongsheng.info x64-ORA-01
192.168.30.148 x64-ORA-02.songdongsheng.info x64-ORA-02</screen>
          </section>

          <section>
            <title>Tuning kernel</title>
            <para>Edit <filename>/etc/sysctl.conf</filename>, you should update to fit your machine.</para>
            <screen>kernel.sem = 250        32000   100      128

fs.file-max = 8388608
fs.aio-max-nr = 1048576

net.ipv4.ip_local_port_range = 9000    65500

net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048576</screen>
          </section>
      </section>
  </section>

  <section>
    <title>Install Oracle 11g R2</title>

    <section>
      <title>Create user oracle</title>
      <section>
        <title>Create user oracle</title>
        <screen># useradd -m -G disk oracle
# passwd oracle</screen>
      </section>

      <section>
        <title>Update profile of oracle</title>
        <para>Edit <filename>~/.bash_profile</filename>, you should update to fit your environment.</para>
        <screen>eval "`dircolors -b`"

export ORACLE_BASE=/opt/oracle
export ORACLE_HOME=/opt/oracle/product/11.2/dg_01
export ORACLE_SID=dg01
export NLS_LANG=AMERICAN_AMERICA.AL32UTF8
export NLS_DATE_FORMAT="YYYY-MM-DD HH24:MI:SS"

export PATH=/sbin:/bin:/usr/sbin:/usr/bin:$ORACLE_HOME/bin
export LD_LIBRARY_PATH=$ORACLE_HOME/lib</screen>
      </section>

      <section>
        <title>Update ulimit of oracle</title>
        <para>Edit <filename>/etc/pam.d/su</filename>, add one line:</para>
        <screen>session         required        pam_limits.so</screen>

        <para>Edit <filename>/etc/security/limits.conf</filename>, add 4 line:</para>
        <screen>@oracle          soft    nproc           16384
@oracle          hard    nproc           32768
@oracle          soft    nofile          65536
@oracle          hard    nofile         131072</screen>
      </section>
    </section>

    <section>
      <title>Configure VNC environment</title>
      <para>If you want to install oracle in console, please skip this section.</para>

        <section>
          <title>Configure VNC password</title>
          <screen>[oracle@x64-ORA-01 ~]$ vncpasswd
Password:
Verify:</screen>
        </section>

        <section>
          <title>Edit VNC startup file</title>

          <para>For beautiful UI, edit <filename>~/.vnc/xstartup</filename>:</para>
          <screen>gnome-session &amp;</screen>

          <para>change <filename>~/.vnc/xstartup</filename> access permissions:</para>
          <screen>[oracle@x64-ORA-01 .vnc]$ chmod +x xstartup</screen>
        </section>

        <section>
          <title>Start VNC server</title>

          <screen>[oracle@x64-ORA-01 ~]$ vncserver

New 'x64-ORA-01:1 (oracle)' desktop is x64-ORA-01:1

Starting applications specified in /home/oracle/.vnc/xstartup
Log file is /home/oracle/.vnc/x64-ORA-01:1.log</screen>
          <para>Then you can use vnc client connect the machine, enjoy it!</para>
        </section>

        <section>
          <title>Stop VNC server</title>

          <para>When you no longer need VNC server:</para>
          <screen>[oracle@x64-ORA-01 ~]$ vncserver -kill :1
Killing Xvnc process ID 2838</screen>
        </section>
    </section>

    <section>
      <title>Install oracle</title>
      <para>Please use AL32UTF8 for default charset.</para>
    </section>
  </section>

  <section>
    <title>Configure Data Guard</title>
    <section>
      <title>Check oracle version</title>
      <screen>SQL> select * from v$version;

BANNER
--------------------------------------------------------------------------------
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
PL/SQL Release 11.2.0.1.0 - Production
CORE    11.2.0.1.0      Production
TNS for Linux: Version 11.2.0.1.0 - Production
NLSRTL Version 11.2.0.1.0 - Production</screen>
    </section>

    <section>
      <title>Preparing the Primary Database</title>

      <section>
        <title>Enable Forced Logging</title>
        <screen>SQL> alter database force logging;
SQL> select inst_id , force_logging from gv$database;</screen>
      </section>

      <section>
        <title>Enable Archiving</title>
        <para>If archiving is not enabled, issue the following statements to
          put the primary database in ARCHIVELOG mode and enable automatic
          archiving:</para>
        <screen>SQL> shutdown immediate;
SQL> startup mount;
SQL> alter database archivelog;
SQL> alter database open;</screen>
      </section>

      <section>
        <title>Configure Redo Transport Authentication</title>
        <para>Data Guard uses Oracle Net sessions to transport redo data and
          control messages between the members of a Data Guard configuration.
          These redo transport sessions are authenticated using either the
          Secure Sockets Layer (SSL) protocol or a remote login password file.</para>

        <para>If the SSL authentication requirements are not met, each member
          of a Data Guard configuration must be configured to use a remote
          login password file and every physical standby database in the
          configuration must have an up-to-date copy of the password file
          from the primary database.<screen>
[oracle@x64-ORA-01 ~]$ cd $ORACLE_HOME/dbs
[oracle@x64-ORA-01 dbs]$ orapwd file=orapwdg01 password=machine4in force=y</screen>
          <note><para>Whenever you grant or revoke
          the SYSDBA or SYSOPER privileges or change the login password of
          a user who has these privileges, you must replace the password
          file at each physical or snapshot standby database in the
          configuration with a fresh copy of the password file from the
          primary database.</para></note></para>
      </section>

      <section>
        <title>Set Primary Database Initialization Parameters</title>
        <para>On the primary database, you define initialization parameters
          that control redo transport services while the database is in the
          primary role. There are additional parameters you need to add that
          control the receipt of the redo data and apply services when the
          primary database is transitioned to the standby role.</para>
        <screen>
[oracle@x64-ORA-01 ~]$ mkdir -p /opt/oracle/oradata/dg01/archive

[oracle@x64-ORA-01 ~]$ sqlplus "/ as sysdba"
SQL> alter system set log_archive_config='dg_config=(dg01,dg02)' scope=both;

System altered.

SQL> alter system set log_archive_dest_1='location=/opt/oracle/oradata/dg01/archive' scope=both;

System altered.

SQL> alter system set log_archive_dest_2='service=dg02 async net_timeout=10 reopen=60 compression=enable valid_for=(online_logfiles,primary_role) db_unique_name=dg02' scope=both;

System altered.</screen>
      </section>

      <section>
        <title>Create a Backup Copy of the Primary Database Datafiles</title>
        <screen>
$ rman nocatalog
RMAN> connect target sys/machine4in
RMAN> backup as compressed backupset database tag 'dg01-full-20091010' format '/opt/oracle/rman/dg01-full-20091010-%s'; </screen>

        <!--screen>
rman &lt;&lt;EOF
connect target sys/machine4in
run {
sql "alter system archive log current";
allocate channel backup_disk1 device type disk maxpiecesize 2000m;
allocate channel backup_disk2 device type disk maxpiecesize 2000m;
backup as compressed backupset
    full database format '/opt/oracle/rman/database_%d_%Y%M%D_%s.dbf'
    skip inaccessible
    plus archivelog format '/opt/oracle/rman/archivelog_%d_%Y%M%D_%s.log' ;
release channel backup_disk1;
release channel backup_disk2;
sql "alter system archive log current";
}
EOF</screen-->
      </section>

      <section>
        <title>Create a Control File for the Standby Database</title>
        <screen>SQL> shutdown immediate;
SQL> startup mount;</screen>

        <para>Then, create the control file for the standby database, and open
          the primary database to user access, as shown in the following example:</para>

        <screen>SQL> alter database create standby controlfile as '/opt/oracle/rman/control01.ctl';
SQL> create pfile='/opt/oracle/rman/dg02.ora' from spfile;

File created.

SQL> create spfile from pfile='/tmp/dg02.ora';

File created.

SQL> alter database open;

  Database altered.

  SQL> archive log list;
  Database log mode              No Archive Mode
  Automatic archival             Disabled
  Archive destination            USE_DB_RECOVERY_FILE_DEST
  Oldest online log sequence     6
  Current log sequence           8</screen>
      </section>

      <section>
        <title>$ORACLE_HOME/network/admin/listener.ora</title>
        <screen>LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
      (ADDRESS = (PROTOCOL = TCP)(HOST = x64-ORA-01.songdongsheng.info)(PORT = 1521))
    )
  )

ADR_BASE_LISTENER = /opt/oracle</screen>
      </section>

      <section>
        <title>$ORACLE_HOME/network/admin/tnsnames.ora</title>
        <screen>DG01 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = x64-ORA-01.songdongsheng.info)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = dg01.songdongsheng.info)
    )
  )

DG02 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = x64-ORA-02.songdongsheng.info)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = dg01.songdongsheng.info)
    )
  )</screen>
      </section>
    </section>


    <section>
      <title>Creating a Physical Standby Database</title>

      <section>
        <title>Install Physical Standby Database Software</title>
        <para>Install as the primary database, but select 'Install database software only',
          do not create database instance.</para>
      </section>

      <section>
        <title>Create password file</title>
        <screen>
[oracle@x64-ORA-01 dbs]$ cd $ORACLE_HOME/dbs
[oracle@x64-ORA-01 dbs]$ orapwd file=orapwdg01 password=machine4in force=y</screen>
      </section>

      <section>
        <title>Create pfile - $ORACLE_HOME/dbs/initstandby.ora</title>
        <important><para>On a primary database, DB_NAME specify the name used when the database was created.
          On a physical standby database, use the DB_NAME of the primary database.</para></important>

        <screen>
*.audit_file_dest='/opt/oracle/admin/dg02/adump'
*.audit_trail='db'
*.compatible='11.2.0.0.0'
*.control_files='/opt/oracle/oradata/dg02/control01.ctl'
*.db_block_size=8192
*.db_domain='songdongsheng.info'
*.db_name='dg01'
*.db_unique_name='dg02'
*.db_recovery_file_dest='/opt/oracle/recovery_area'
*.db_recovery_file_dest_size=4070572032
*.diagnostic_dest='/opt/oracle'
*.dispatchers='(PROTOCOL=TCP) (SERVICE=dg02XDB)'
*.memory_target=419430400
*.open_cursors=300
*.processes=150
*.remote_login_passwordfile='EXCLUSIVE'
*.undo_management=auto
*.undo_tablespace='UNDOTBS1'

*.log_archive_config='dg_config=(dg01,dg02)'

# for primary database
# *.log_archive_dest_1='location=/opt/oracle/oradata/dg01/archive'
# *.log_archive_dest_2='service=dg02 async net_timeout=10 reopen=60 compression=enable valid_for=(online_logfiles,primary_role) db_unique_name=dg02'

# for standby database
*.log_archive_dest_1='location=/opt/oracle/oradata/dg02/archive'
*.log_archive_dest_2='service=dg01 async net_timeout=10 reopen=60 compression=enable valid_for=(online_logfiles,primary_role) db_unique_name=dg01'

*.fal_server=dg01
*.fal_client=dg02

*.standby_file_management=auto</screen>
      </section>

      <section>
        <title>Copy data files and control files</title>
        <screen>[oracle@x64-ORA-01 rman]$ rsync -e ssh -v --progress * x64-ORA-02:/opt/oracle/rman
archivelog_DG01_20091009_30.log
    19303936 100%    4.80MB/s    0:00:03 (xfer#1, to-check=9/10)
archivelog_DG01_20091009_31.log
     7548416 100%    2.76MB/s    0:00:02 (xfer#2, to-check=8/10)
archivelog_DG01_20091009_32.log
      634880 100%    1.03MB/s    0:00:00 (xfer#3, to-check=7/10)
archivelog_DG01_20091009_37.log
       55808 100%   92.06kB/s    0:00:00 (xfer#4, to-check=6/10)
database_DG01_20091009_33.dbf
   187252736 100%    6.89MB/s    0:00:25 (xfer#5, to-check=5/10)
database_DG01_20091009_34.dbf
    82771968 100%    6.19MB/s    0:00:12 (xfer#6, to-check=4/10)
database_DG01_20091009_35.dbf
     1114112 100%    2.14MB/s    0:00:00 (xfer#7, to-check=3/10)
database_DG01_20091009_36.dbf
       98304 100%  189.72kB/s    0:00:00 (xfer#8, to-check=2/10)

sent 298819670 bytes  received 240 bytes  6036765.86 bytes/sec
total size is 298782519  speedup is 1.00</screen>

        <screen>mkdir $ORACLE_BASE/admin/$ORACLE_SID/pfile
mkdir /opt/oracle/admin/dg02/adump
mkdir /opt/oracle/recovery_area
mkdir /opt/oracle/oradata/dg02/archive</screen>

      </section>

      <section>
        <title>$ORACLE_HOME/network/admin/listener.ora</title>
        <screen>LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
      (ADDRESS = (PROTOCOL = TCP)(HOST = x64-ORA-02.songdongsheng.info)(PORT = 1521))
    )
  )

ADR_BASE_LISTENER = /opt/oracle</screen>
      </section>

      <section>
        <title>$ORACLE_HOME/network/admin/tnsnames.ora</title>
        <screen>DG01 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = x64-ORA-01.songdongsheng.info)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = dg01.songdongsheng.info)
    )
  )

DG02 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = x64-ORA-02.songdongsheng.info)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = dg01.songdongsheng.info)
    )
  )</screen>
      </section>

      <section>
        <title>Mount standby database </title>
        <screen>
[oracle@x64-ORA-02 dg02]$ sqlplus "/ as sysdba"

SQL*Plus: Release 11.2.0.1.0 Production on Fri Oct 9 05:57:48 2009

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Connected to an idle instance.

SQL> create spfile from pfile='$ORACLE_HOME/dbs/initstandby.ora';
SQL> create pfile='/opt/oracle/product/11.2/dg_02/dbs/initdg02.ora' from spfile;
SQL> startup nomount
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size                  2213936 bytes
Variable Size             268437456 bytes
Database Buffers          138412032 bytes
Redo Buffers                8482816 bytes
SQL> alter database mount standby database;</screen>
      </section>

      <section>
        <title>restore standby database</title>
        <screen>rman &lt;&lt;EOF
connect target sys/machine4in
run {
SET ARCHIVELOG DESTINATION TO '/opt/oracle/rman';
RESTORE DATABASE;
RECOVER DATABASE; # restores and recovers logs automatically
}
EOF</screen>
      </section>

      <section>
        <title>Prepare the Standby Database to Receive Redo Data</title>
        <screen>
SQL> SELECT GROUP#, BYTES FROM V$LOG;
SQL> SELECT GROUP#, BYTES FROM V$STANDBY_LOG;
SQL> ALTER DATABASE ADD STANDBY LOGFILE ('/opt/oracle/oradata/dg02/sredo01.log') SIZE 50M;
SQL> ALTER DATABASE ADD STANDBY LOGFILE ('/opt/oracle/oradata/dg02/sredo02.log') SIZE 50M;
SQL> ALTER DATABASE ADD STANDBY LOGFILE ('/opt/oracle/oradata/dg02/sredo03.log') SIZE 50M;
SQL> ALTER DATABASE ARCHIVELOG;</screen>
      </section>

      <section>
        <title>Start Redo Apply.</title>
        <screen>
SQL> alter database recover managed standby database using current logfile disconnect from session;
SQL> alter database open read only;</screen>
      </section>

      <section>
        <title>Shutting Down a Physical Standby Database</title>
        <screen>
SQL> SELECT PROCESS, STATUS FROM V$MANAGED_STANDBY;
SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;
SQL> SHUTDOWN;</screen>
      </section>

      <section>
        <title>Verify the Physical Standby Database Is Performing Properly</title>

        <section>
          <title>Test connection</title>
          <para>On the primary and standby machine, run:</para>
          <screen>
  sqlplus system/machine4in@dg01
  sqlplus system/machine4in@dg02  </screen>
        </section>

        <section>
          <title>Identify the existing archived redo log files</title>
          <para>On the standby database, query the V$ARCHIVED_LOG view to identify existing
            files in the archived redo log. For example:</para>
          <screen>
SQL> SELECT SEQUENCE#, APPLIED,
    to_char(FIRST_TIME, 'YYYY-MM-DD HH24:MI:SS') as FIRST_TIME,
    to_char(NEXT_TIME, 'YYYY-MM-DD HH24:MI:SS') as NEXT_TIME
    FROM V$ARCHIVED_LOG
    ORDER BY SEQUENCE#;</screen>
        </section>

        <section>
          <title>Force a log switch to archive the current online redo log file</title>
          <para>On the primary database, issue the ALTER SYSTEM SWITCH LOGFILE statement to
            force a log switch and archive the current online redo log file group:</para>
          <screen>
SQL> ALTER SYSTEM SWITCH LOGFILE;
SQL> select max(sequence#) from v$archived_log;</screen>
        </section>

        <section>
          <title>Verify the new redo data was archived on the standby database</title>
          <para>On the standby database, query the V$ARCHIVED_LOG view to verify the redo
            data was received and archived on the standby database:</para>
          <screen>
SQL> SELECT SEQUENCE#, APPLIED,
    to_char(FIRST_TIME, 'YYYY-MM-DD HH24:MI:SS') as FIRST_TIME,
    to_char(NEXT_TIME, 'YYYY-MM-DD HH24:MI:SS') as NEXT_TIME
    FROM V$ARCHIVED_LOG
    ORDER BY SEQUENCE#;</screen>
        </section>

        <section>
          <title>Verify that received redo has been applied</title>
          <para>On the standby database, query the V$ARCHIVED_LOG view to verify that received redo has been applied:</para>
          <screen>
SQL> SELECT SEQUENCE#,APPLIED FROM V$ARCHIVED_LOG ORDER BY SEQUENCE#;</screen>
        </section>

        <section>
          <title>Some useful commands</title>
          <screen>
SQL> select dest_name,status,error from v$archive_dest where error is not null;

SQL> select sequence# from v$log_history;
SQL> select sequence#,applied from v$archived_log;
SQL> select process,status from v$managed_standby;

$ rman nocatalog
RMAN> show all;
RMAN> connect target sys/machine4in@dg02
RMAN> report obsolete;
RMAN> delete obsolete;

RMAN> list backup;
RMAN> list expired backup;
RMAN> crosscheck backup;
RMAN> delete expired backup;
RMAN> crosscheck backupset 36,37;

RMAN> list archivelog all;
RMAN> list expired archivelog all;
RMAN> crosscheck archivelog all;
RMAN> delete expired archivelog all;
RMAN> delete archivelog all completed before 'sysdate';

RMAN> backup as compressed backupset format '/opt/oracle/rman/archivelog-%d-%I-%T-%s.log' archivelog all delete input;
RMAN> backup as compressed backupset format '/opt/oracle/rman/spfile-%d-%I-%T-%s' spfile;
RMAN> backup as compressed backupset format '/opt/oracle/rman/controlfile-%d-%I-%T-%s' current controlfile;
RMAN> backup as compressed backupset database tag 'dg02-full-%d-%I-%T-%s' format '/opt/oracle/rman/dg02-full-%d-%I-%T-%s';</screen>
        </section>
      </section>
    </section>
  </section>

  <section>
    <title>Configure Streams Replication</title>

    <section>
      <title>Preparing for Oracle Streams Replication</title>

      <section>
        <title>Overview of Oracle Streams Replication</title>
        <para><emphasis>Replication</emphasis> is the process of sharing database objects and data at multiple databases.
          To maintain replicated database objects and data at multiple databases, a change to one of
          these database objects at a database is shared with the other databases. Through this
          process, the database objects and data are kept synchronized at all of the databases in
          the replication environment. In an Oracle Streams replication environment, the database
          where a change originates is called the <emphasis>source database</emphasis>, and a database where a change
          is shared is called a <emphasis>destination database</emphasis>.</para>
        <para>When you use Oracle Streams, replication of a data manipulation language (DML) or data definition
          language (DDL) change typically includes three steps:</para>
        <orderedlist>
          <listitem><para>A capture process, a synchronous capture, or an application creates
            one or more logical change records (LCRs) and enqueues them. An LCR is a message
            with a specific format that describes a database change. A capture process reformats
            changes captured from the redo log into LCRs, a synchronous capture uses an internal
            mechanism to reformat changes into LCRs, and an application can construct LCRs.
            If the change was a DML operation, then each row LCR encapsulates a row change
            resulting from the DML operation to a replicated table at the source database.
            If the change was a DDL operation, then a DDL LCR encapsulates the DDL change that
            was made to a replicated database object at a source database.</para></listitem>
          <listitem><para>A propagation propagates the staged LCRs to another queue, which
            usually resides in a database that is separate from the database where the LCRs
            were captured. An LCR can be propagated to several different queues before it
            arrives at a destination database.</para></listitem>
          <listitem><para>At a destination database, an apply process consumes the change.
            An apply process can dequeue the LCR and apply it directly to the replicated
            database object, or an apply process can dequeue the LCR and send it to an apply
            handler. In an Oracle Streams replication environment, an apply handler performs
            customized processing of an LCR. An apply handler can apply the change in the
            LCR to the replicated database object, or it can consume the LCR in some other way.</para></listitem>
        </orderedlist>
      </section>

      <section>
        <title>Decisions to Make Before Configuring Oracle Streams Replication</title>

        <para>Make the following decisions before configuring Oracle Streams replication:</para>
          <itemizedlist>
            <listitem><para>Decide Which Type of Replication Environment to Configure</para></listitem>
            <listitem><para>Decide Whether to Configure Local or Downstream Capture for the Source Database</para></listitem>
            <listitem><para>Decide Whether Changes Are Allowed at One Database or at Multiple Databases</para></listitem>
            <listitem><para>Decide Whether the Replication Environment Will Have Nonidentical Replicas</para></listitem>
            <listitem><para>Decide Whether the Replication Environment Will Use Apply Handlers</para></listitem>
            <listitem><para>Decide Whether to Maintain DDL Changes</para></listitem>
            <listitem><para>Decide How to Configure the Replication Environment</para></listitem>
          </itemizedlist>
      </section>

      <section>
        <title>Tasks to Complete Before Configuring Oracle Streams Replication</title>
          <itemizedlist>
            <listitem><para>Configuring an Oracle Streams Administrator on All Databases</para></listitem>
            <listitem><para>Configuring Network Connectivity and Database Links</para></listitem>
            <listitem><para>Ensuring That Each Source Database Is In ARCHIVELOG Mode</para></listitem>
            <listitem><para>Setting Initialization Parameters Relevant to Oracle Streams</para></listitem>
            <listitem><para>Configuring the Oracle Streams Pool</para></listitem>
            <listitem><para>Specifying Supplemental Logging</para></listitem>
            <listitem><para>Configuring Log File Transfer to a Downstream Capture Database</para></listitem>
            <listitem><para>Adding Standby Redo Logs for Real-Time Downstream Capture</para></listitem>
          </itemizedlist>
      </section>

    </section>

    <section>
      <title>Common Tasks of Replication Environment</title>

      <section>
        <title>Setting Initialization Parameters Relevant to Oracle Streams</title>
        <screen>$ sqlplus strmadmin/machine4in@dre
SQL> alter system set global_names=true scope=both;
SQL> alter system set log_archive_config='send, receive, nodg_config' scope=both;

$ sqlplus strmadmin/machine4in@dg01
SQL> alter system set global_names=true scope=both;
SQL> alter system set log_archive_config='send, receive, dg_config=(dg01,dg02)' scope=both;</screen>
      </section>

      <section>
        <title>Configuring Network Connectivity and Database Links</title>

        <para>Check or update <emphasis>global_name</emphasis> of Oracle.</para>

        <important><para>You must validate the <emphasis>global_name</emphasis>,
          and set the <emphasis>database link name</emphasis> to the
          <emphasis>global_name</emphasis> in the other database.</para></important>

        <screen>
SQL> alter database rename global_name to DRE.SONGDONGSHENG.INFO;

$ sqlplus strmadmin/machine4in@dre
SQL> select * from global_name;
DRE.SONGDONGSHENG.INFO

$ sqlplus strmadmin/machine4in@dg01
SQL> select * from global_name;
DG01.SONGDONGSHENG.INFO

SQL> select count(1) from dre.abc@dg01.songdongsheng.info;
SQL> select count(1) from dre.abc@dre.songdongsheng.info;</screen>

        <para>Edit <filename>/etc/hosts</filename>, you should update to fit your machine.</para>
        <screen>192.168.30.76   IN-ORACLE-01.songdongsheng.info IN-ORACLE-01
192.168.30.126  x64-ORA-01.songdongsheng.info x64-ORA-01</screen>

        <para>Edit <filename>$ORACLE_HOME/network/admin/tnsnames.ora</filename>, you should update to fit your machine.</para>
        <screen>DRE =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.30.76)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = dre)
    )
  )

DG01 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = x64-ORA-01.songdongsheng.info)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = dg01.songdongsheng.info)
    )
  )</screen>

        <para>The following statement creates the database link from the source database to the destination database:</para>
<screen>
$ sqlplus strmadmin/machine4in@dre
SQL> drop database link DG01.SONGDONGSHENG.INFO;
SQL> CREATE DATABASE LINK DG01.SONGDONGSHENG.INFO
     CONNECT TO strmadmin IDENTIFIED BY machine4in
     USING '(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.30.126)(PORT=1521))
     (CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=dg01.songdongsheng.info)))';</screen>

        <para>The following statement creates the database link from the source database to the destination database:</para>
<screen>
$ sqlplus strmadmin/machine4in@dg01
SQL> drop database link DRE.SONGDONGSHENG.INFO;
SQL> CREATE DATABASE LINK DRE.SONGDONGSHENG.INFO
     CONNECT TO strmadmin IDENTIFIED BY machine4in
     USING '(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.30.76)(PORT=1521))
     (CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=dre)))';</screen>
      </section>

      <section>
        <title>Ensuring That Each Source Database Is In ARCHIVELOG Mode</title>
<screen>
SQL> archive log list;
Database log mode              No Archive Mode
Automatic archival             Disabled
Archive destination            /home/oracle/oracle/product/10.2/dre/dbs/arch
Oldest online log sequence     110
Current log sequence           112

SQL> shutdown immediate;
SQL> startup mount;
SQL> alter database archivelog;
SQL> alter database open;</screen>
      </section>

      <section>
        <title>Configuring an Oracle Streams Administrator on All Databases</title>
        <para>To configure and manage an Oracle Streams environment, either create a new user
          with the appropriate privileges or grant these privileges to an existing user. You
          should not use the SYS or SYSTEM user as an Oracle Streams administrator, and the
          Oracle Streams administrator should not use the SYSTEM tablespace as its default
          tablespace.</para>

        <para>Typically, the user name for the Oracle Streams administrator is strmadmin,
          but any user with the proper privileges can be an Oracle Streams administrator.
          The examples in this section use strmadmin for the Oracle Streams administrator
          user name.</para>

        <para>Create a separate tablespace for the Oracle Streams administrator at each
          participating Oracle Streams database. This tablespace stores any objects
          created in the Oracle Streams administrator schema, including any spillover of
          messages from the buffered queues owned by the schema.</para>

        <para>The following statement creates a new tablespace for the Oracle Streams administrator:</para>
        <screen>
SQL> CREATE TABLESPACE streams_tbs
  DATAFILE '/home/oracle/oracle/product/10.2/dre/oradata/dre/streams_tbs.dbf'
  SIZE 24M REUSE AUTOEXTEND ON NEXT 8M MAXSIZE UNLIMITED;</screen>
        <!--screen>
SQL> ALTER DATABASE
    DATAFILE '/opt/oracle/oradata/dg01/streams_tbs.dbf'
    AUTOEXTEND ON NEXT 8M;

SQL> CREATE TABLESPACE streams_tbs
  DATAFILE '/opt/oracle/oradata/dg01/streams_tbs.dbf'
  SIZE 24M REUSE AUTOEXTEND ON NEXT 8M MAXSIZE UNLIMITED;<screen-->

        <para>Create a user named strmadmin and specify that this user uses the streams_tbs tablespace,
          run the following statement:</para>
        <screen>
SQL> CREATE USER strmadmin IDENTIFIED BY machine4in
   DEFAULT TABLESPACE streams_tbs
   QUOTA UNLIMITED ON streams_tbs;</screen>

        <para>Grant the Oracle Streams administrator DBA role:</para>
        <screen>SQL> GRANT DBA TO strmadmin;</screen>

        <para>Run the GRANT_ADMIN_PRIVILEGE procedure in the DBMS_STREAMS_AUTH package.</para>
        <screen>
BEGIN
  DBMS_STREAMS_AUTH.GRANT_ADMIN_PRIVILEGE(
    grantee          => 'strmadmin',
    grant_privileges => TRUE);
END;
/</screen>
      </section>
    </section>

    <section>
      <title>Replication - Table Based</title>
      <section>
        <title>Set up streams at the destination database</title>
        <para></para>
        <screen>
$ sqlplus strmadmin/machine4in@dg01

REM
REM    Create streams queue
REM
BEGIN
 DBMS_STREAMS_ADM.SET_UP_QUEUE(
   queue_user => 'STRMADMIN');
END;
/

REM
REM    Add apply rules for tables at the destination database
REM
BEGIN
 DBMS_STREAMS_ADM.ADD_TABLE_RULES(
   table_name => 'DRE.ABC',
   streams_type => 'APPLY',
   streams_name => 'STRMADMIN_APPLY',
   queue_name => 'STRMADMIN.STREAMS_QUEUE',
   include_dml => true,
   include_ddl => true,
   source_database => 'DRE.SONGDONGSHENG.INFO');
END;
/</screen>
      </section>

      <section>
        <title>Set up streams at the source database</title>
        <para></para>
        <screen>
$ sqlplus strmadmin/machine4in@dre

REM
REM    Turn on supplemental logging
REM
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY,UNIQUE INDEX) COLUMNS;

REM
REM    Switch log file
REM
ALTER SYSTEM SWITCH LOGFILE;

REM
REM    Create streams queue
REM
BEGIN
 DBMS_STREAMS_ADM.SET_UP_QUEUE(
   queue_user => 'STRMADMIN');
END;
/

REM
REM    Add capture rules for tables at the source database
REM
BEGIN
 DBMS_STREAMS_ADM.ADD_TABLE_RULES(
   table_name => 'DRE.ABC',
   streams_type => 'CAPTURE',
   streams_name => 'STRMADMIN_CAPTURE',
   queue_name => 'STRMADMIN.STREAMS_QUEUE',
   include_dml => true,
   include_ddl => true);
END;
/

REM
REM    Add propagation rules for tables at the source database
REM
BEGIN
 DBMS_STREAMS_ADM.ADD_TABLE_PROPAGATION_RULES(
   table_name => 'DRE.ABC',
   streams_name => 'STRMADMIN_PROPAGATE',
   source_queue_name => 'STRMADMIN.STREAMS_QUEUE',
   destination_queue_name => 'STRMADMIN.STREAMS_QUEUE@DG01.SONGDONGSHENG.INFO',
   include_dml => true,
   include_ddl => true);
END;
/

REM
REM    Propagation latency is the maximum wait, in seconds, in the propagation
REM    window for a message to be propagated after it is enqueued. Set the
REM    propagation latency to an appropriate value for each propagation in your
REM    Oracle Streams replication environment. The default propagation latency
REM    value is 60.
REM
BEGIN
  DBMS_AQADM.ALTER_PROPAGATION_SCHEDULE(
  queue_name => 'STRMADMIN.STREAMS_QUEUE',
  destination => 'DG01.SONGDONGSHENG.INFO',
  latency => 0);
END;
/</screen>
      </section>


      <section>
        <title>Set the Instantiation SCN for the tables at the destination database</title>
<screen>
$ exp strmadmin/machine4in@dre TABLES=DRE.ABC FILE=tables.dmp OBJECT_CONSISTENT=Y

$ imp strmadmin/machine4in@dg01 FULL=Y FILE=tables.dmp IGNORE=Y COMMIT=Y STREAMS_CONFIGURATION=N STREAMS_INSTANTIATION=Y

$ sqlplus strmadmin/machine4in@dre
DECLARE
  iscn  NUMBER;         /* Variable to hold instantiation SCN value */
BEGIN
  iscn := DBMS_FLASHBACK.GET_SYSTEM_CHANGE_NUMBER();
  DBMS_APPLY_ADM.SET_TABLE_INSTANTIATION_SCN@DG01.SONGDONGSHENG.INFO(
    source_object_name    => 'DRE.ABC',
    source_database_name  => 'DRE.SONGDONGSHENG.INFO',
    instantiation_scn     => iscn);
END;
/
        </screen>
      </section>

      <section>
        <title>Start apply process at the destination database</title>
        <screen>$ sqlplus strmadmin/machine4in@dg01

REM
REM Set the disable_on_error parameter to n so that the apply process will not be disabled
REM if it encounters an error, and start the apply process at DG01.SONGDONGSHENG.INFO.
REM

BEGIN
  DBMS_APPLY_ADM.SET_PARAMETER(
    apply_name  => 'STRMADMIN_APPLY',
    parameter   => 'disable_on_error',
    value       => 'N');
END;
/

REM
REM    Start apply process at the destination database
REM
DECLARE
 v_started number;
BEGIN
  SELECT decode(status, 'ENABLED', 1, 0) INTO v_started
    FROM DBA_APPLY WHERE APPLY_NAME = 'STRMADMIN_APPLY';

  if (v_started = 0) then
    DBMS_APPLY_ADM.START_APPLY(apply_name  => 'STRMADMIN_APPLY');
  end if;
END;
/

$ sqlplus strmadmin/machine4in@dre

DECLARE
 v_started number;
BEGIN
  SELECT decode(status, 'ENABLED', 1, 0) INTO v_started
    FROM DBA_CAPTURE WHERE CAPTURE_NAME = 'STRMADMIN_CAPTURE';

  if (v_started = 0) then
    DBMS_CAPTURE_ADM.START_CAPTURE(capture_name  => 'STRMADMIN_CAPTURE');
  end if;
END;
/</screen>
      </section>

      <section>
        <title>Two-Way Replication</title>
        <para>If we redo the replicate process with exchange the destination
          database and the source database, then we have two-way replication.</para>
      </section>
    </section>

    <section>
      <title>Replication - Schema Based</title>

      <section>
        <title>Set up streams at the destination database</title>
        <screen>$ sqlplus strmadmin/machine4in@dg01

REM
REM    Add apply rules for schemes at the destination database
REM
BEGIN
 DBMS_STREAMS_ADM.ADD_SCHEMA_RULES(
   schema_name => 'SCOTT',
   streams_type => 'APPLY',
   streams_name => 'STRMADMIN_APPLY',
   queue_name => 'STRMADMIN.STREAMS_QUEUE',
   include_dml => true,
   include_ddl => true,
   source_database => 'DRE.SONGDONGSHENG.INFO');
END;
/</screen>
      </section>

      <section>
        <title>Set up streams at the source database</title>
        <screen>$ sqlplus strmadmin/machine4in@dre

REM
REM    Turn on supplemental logging
REM
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY,UNIQUE INDEX) COLUMNS;

REM
REM    Switch log file
REM
ALTER SYSTEM SWITCH LOGFILE;

REM
REM    Add propagation rules for schemes at the source database
REM
BEGIN
 DBMS_STREAMS_ADM.ADD_SCHEMA_PROPAGATION_RULES(
   schema_name => 'SCOTT',
   streams_name => 'STRMADMIN_PROPAGATE',
   source_queue_name => 'STRMADMIN.STREAMS_QUEUE',
   destination_queue_name => 'STRMADMIN.STREAMS_QUEUE@DG01.SONGDONGSHENG.INFO',
   include_dml => true,
   include_ddl => true,
   source_database => 'DRE.SONGDONGSHENG.INFO');
END;
/

REM
REM    Propagation latency is the maximum wait, in seconds, in the propagation
REM    window for a message to be propagated after it is enqueued. Set the
REM    propagation latency to an appropriate value for each propagation in your
REM    Oracle Streams replication environment. The default propagation latency
REM    value is 60.
REM
BEGIN
  DBMS_AQADM.ALTER_PROPAGATION_SCHEDULE(
  queue_name => 'STRMADMIN.STREAMS_QUEUE',
  destination => 'DG01.SONGDONGSHENG.INFO',
  latency => 0);
END;
/

REM
REM    Add capture rules for schemes at the source database
REM
BEGIN
 DBMS_STREAMS_ADM.ADD_SCHEMA_RULES(
   schema_name => 'SCOTT',
   streams_type => 'CAPTURE',
   streams_name => 'STRMADMIN_CAPTURE',
   queue_name => 'STRMADMIN.STREAMS_QUEUE',
   include_dml => true,
   include_ddl => true,
   source_database => 'DRE.SONGDONGSHENG.INFO');
END;
/</screen>
      </section>

      <section>
        <title>Set the Instantiation SCN for the tables at the destination database</title>
        <screen>$ exp strmadmin/machine4in@dre OWNER=SCOTT FILE=schemas.dmp OBJECT_CONSISTENT=Y

$ imp strmadmin/machine4in@dg01 FULL=Y FILE=schemas.dmp IGNORE=Y COMMIT=Y STREAMS_CONFIGURATION=N STREAMS_INSTANTIATION=Y</screen>
      </section>

      <section>
        <title>Start apply process at the destination database</title>
        <screen>$ sqlplus strmadmin/machine4in@dg01

REM
REM Set the disable_on_error parameter to n so that the apply process will not be disabled
REM if it encounters an error, and start the apply process at DG01.SONGDONGSHENG.INFO.
REM

BEGIN
  DBMS_APPLY_ADM.SET_PARAMETER(
    apply_name  => 'STRMADMIN_APPLY',
    parameter   => 'disable_on_error',
    value       => 'N');
END;
/

REM
REM    Start apply process at the destination database
REM
DECLARE
 v_started number;
BEGIN
  SELECT decode(status, 'ENABLED', 1, 0) INTO v_started
    FROM DBA_APPLY WHERE APPLY_NAME = 'STRMADMIN_APPLY';

  if (v_started = 0) then
    DBMS_APPLY_ADM.START_APPLY(apply_name  => 'STRMADMIN_APPLY');
  end if;
END;
/

$ sqlplus strmadmin/machine4in@dre

DECLARE
 v_started number;
BEGIN
  SELECT decode(status, 'ENABLED', 1, 0) INTO v_started
    FROM DBA_CAPTURE WHERE CAPTURE_NAME = 'STRMADMIN_CAPTURE';

  if (v_started = 0) then
    DBMS_CAPTURE_ADM.START_CAPTURE(capture_name  => 'STRMADMIN_CAPTURE');
  end if;
END;
/</screen>
      </section>

      <section>
        <title>Two-Way Replication</title>
        <para>If we redo the replicate process with exchange the destination database and the
          source database, then we have two-way replication.</para>
      </section>
    </section>

    <section>
      <title>Replication - Conflict Resolution</title>
      <para>A <emphasis>conflict</emphasis> is a mismatch between the old values in an LCR
        and the expected data in a table. Conflicts can occur in an Oracle Streams
        environment that permits <emphasis>concurrent</emphasis> data manipulation language
        (DML) operations on the same data at <emphasis>multiple databases</emphasis>.
        In an Oracle Streams environment, DML conflicts can occur only when an apply process
        is applying a message that contains a row change resulting from a DML operation.
        This type of message is called a row logical change record, or row LCR. An apply
        process automatically detects conflicts caused by row LCRs.</para>
      <para>For example, when two transactions originating at different databases update the
        same row at nearly the same time, a conflict can occur. When you configure an Oracle
        Streams environment, you must consider whether conflicts can occur. You can configure
        conflict resolution to resolve conflicts automatically, if your system design permits
        conflicts.</para>
      <para>In general, you <emphasis>should</emphasis> try to design an Oracle Streams
        environment that <emphasis>avoids</emphasis> the possibility of conflicts. Using the
        conflict avoidance techniques, most system designs can avoid conflicts in all or a
        large percentage of the shared data. However, many applications require that some
        percentage of the shared data be updatable at multiple databases at any time. If
        this is the case, then you must address the possibility of conflicts.</para>

      <section>
        <title>Conflict Types in an Oracle Streams Environment</title>
        <itemizedlist>
          <listitem><para>Update Conflicts in an Oracle Streams Environment</para></listitem>
          <listitem><para>Uniqueness Conflicts in an Oracle Streams Environment</para></listitem>
          <listitem><para>Delete Conflicts in an Oracle Streams Environment</para></listitem>
          <listitem><para>Foreign Key Conflicts in an Oracle Streams Environment</para></listitem>
          <listitem><para>Ordering conflicts can occur in an Oracle Streams environment
            when three or more databases share data and the data is updated at two or
            more of these databases.</para></listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Conflict Detection in an Oracle Streams Environment</title>
        <para>An apply process detects update, uniqueness, delete, and foreign key conflicts
          as follows:</para>

        <itemizedlist>
          <listitem><para>An apply process detects an update conflict if there is any
            difference between the old values for a row in a row LCR and the current
            values of the same row at the destination database.</para></listitem>
          <listitem><para>An apply process detects a uniqueness conflict if a uniqueness
            constraint violation occurs when applying an LCR that contains an insert or
            update operation.</para></listitem>
          <listitem><para>An apply process detects a delete conflict if it cannot find
            a row when applying an LCR that contains an update or delete operation,
            because the primary key of the row does not exist.</para></listitem>
          <listitem><para>An apply process detects a foreign key conflict if a foreign
            key constraint violation occurs when applying an LCR.</para></listitem>
        </itemizedlist>

        <para>A conflict can be detected when an apply process attempts to apply an LCR
          directly or when an apply process handler, such as a DML handler, runs the
          EXECUTE member procedure for an LCR. A conflict can also be detected when either
          the EXECUTE_ERROR or EXECUTE_ALL_ERRORS procedure in the DBMS_APPLY_ADM package
          is run.</para>

      </section>

      <section>
        <title>Conflict Avoidance in an Oracle Streams Environment</title>

        <section>
          <title>Use a Primary Database Ownership Model</title>
          <para>You can avoid the possibility of conflicts by limiting the number of databases
            in the system that have simultaneous update access to the tables containing shared
            data. Primary ownership prevents all conflicts, because only a single database
            permits updates to a set of shared data. Applications can even use row and column
            subsetting to establish more granular ownership of data than at the table level.
            For example, applications might have update access to specific columns or rows in
            a shared table on a database-by-database basis.</para>
        </section>

        <section>
          <title>Avoid Specific Types of Conflicts</title>
          <para>If a primary database ownership model is too restrictive for your application
            requirements, then you can use a shared ownership data model, which means that
            conflicts might be possible. Even so, typically you can use some simple strategies
            to avoid specific types of conflicts.</para>
        </section>

        <section>
          <title>Avoid Uniqueness Conflicts in an Oracle Streams Environment</title>
          <para>You can avoid uniqueness conflicts by ensuring that each database uses unique
            identifiers for shared data.</para>
        </section>

        <section>
          <title>Avoid Delete Conflicts in an Oracle Streams Environment</title>
          <para>Always avoid delete conflicts in shared data environments. In general,
            applications that operate within a shared ownership data model should not delete
            rows using DELETE statements. Instead, applications should mark rows for deletion
            and then configure the system to purge logically deleted rows periodically.</para>
        </section>

        <section>
          <title>Avoid Update Conflicts in an Oracle Streams Environment</title>
          <para>After trying to eliminate the possibility of uniqueness and delete conflicts,
            you should also try to limit the number of possible update conflicts. However,
            in a shared ownership data model, update conflicts cannot be avoided in all cases.
            If you cannot avoid all update conflicts, then you must understand the types of
            conflicts possible and configure the system to resolve them if they occur.</para>
        </section>
      </section>

      <section>
        <title>Conflict Resolution in an Oracle Streams Environment</title>
        <para>After an update conflict has been detected, a conflict handler can attempt to
          resolve it. Oracle Streams provides prebuilt conflict handlers to resolve update
          conflicts, but not uniqueness, delete, foreign key, or ordering conflicts. However,
          you can build your own custom conflict handler to resolve data conflicts specific
          to your business rules. Such a conflict handler can be part of a procedure DML
          handler or an error handler.</para>

        <para>Oracle provides the following types of prebuilt update conflict handlers for an
          Oracle Streams environment: <emphasis>OVERWRITE</emphasis>,
          <emphasis>DISCARD</emphasis>, <emphasis>MAXIMUM</emphasis>,
          and <emphasis>MINIMUM</emphasis>.</para>
      </section>

      <section>
        <title>Managing Oracle Streams Conflict Detection and Resolution</title>

        <section>
          <title>Setting an Update Conflict Handler</title>
          <para>Set an update conflict handler using the SET_UPDATE_CONFLICT_HANDLER procedure
            in the DBMS_APPLY_ADM package. e.g.</para>
          <screen>DECLARE
  cols DBMS_UTILITY.NAME_ARRAY;
  BEGIN
    cols(1) := 'job_title';
    cols(2) := 'min_salary';
    cols(3) := 'max_salary';
    DBMS_APPLY_ADM.SET_UPDATE_CONFLICT_HANDLER(
      object_name       => 'hr.jobs',
      method_name       => 'OVERWRITE',
      resolution_column => 'job_title',
      column_list       => cols);
END;
/</screen>
        </section>

        <section>
          <title>Modifying an Existing Update Conflict Handler</title>
          <para>You can modify an existing update conflict handler by running the
            SET_UPDATE_CONFLICT_HANDLER procedure in the DBMS_APPLY_ADM package. To update an
            existing conflict handler, specify the same table and resolution column as the
            existing conflict handler. e.g.</para>
            <screen>DECLARE
  cols DBMS_UTILITY.NAME_ARRAY;
  BEGIN
    cols(1) := 'job_title';
    cols(2) := 'min_salary';
    cols(3) := 'max_salary';
    DBMS_APPLY_ADM.SET_UPDATE_CONFLICT_HANDLER(
      object_name       => 'hr.jobs',
      method_name       => 'DISCARD',
      resolution_column => 'job_title',
      column_list       => cols);
END;
/</screen>
        </section>

        <section>
          <title>Removing an Existing Update Conflict Handler</title>
          <para>You can remove an existing update conflict handler by running the
            SET_UPDATE_CONFLICT_HANDLER procedure in the DBMS_APPLY_ADM package. To remove a an
            existing conflict handler, specify NULL for the method, and specify the same table,
            column list, and resolution column as the existing conflict handler. e.g.</para>
            <screen>DECLARE
  cols DBMS_UTILITY.NAME_ARRAY;
  BEGIN
    cols(1) := 'job_title';
    cols(2) := 'min_salary';
    cols(3) := 'max_salary';
    DBMS_APPLY_ADM.SET_UPDATE_CONFLICT_HANDLER(
      object_name       => 'hr.jobs',
      method_name       => NULL,
      resolution_column => 'job_title',
      column_list       => cols);
END;
/</screen>
        </section>

        <section>
          <title>Stopping Conflict Detection for Nonkey Columns</title>
          <para>You can stop conflict detection for nonkey columns using the COMPARE_OLD_VALUES
            procedure in the DBMS_APPLY_ADM package. e.g.</para>
            <screen>DECLARE
  cols DBMS_UTILITY.LNAME_ARRAY;
  BEGIN
    cols(1) := 'first_name';
    cols(2) := 'last_name';
    cols(3) := 'email';
    cols(4) := 'phone_number';
    cols(5) := 'hire_date';
    cols(6) := 'job_id';
    cols(7) := 'salary';
    cols(8) := 'commission_pct';
  DBMS_APPLY_ADM.COMPARE_OLD_VALUES(
    object_name  => 'hr.employees',
    column_table => cols,
    operation    => '*',
    compare      => FALSE);
END;
/</screen>
        </section>
      </section>

      <section>
        <title>Monitoring Conflict Detection and Update Conflict Handlers</title>

        <section>
          <title>Displaying Information About Conflict Detection</title>

          <para>You can stop conflict detection for nonkey columns using the COMPARE_OLD_VALUES
            procedure in the DBMS_APPLY_ADM package. When you use this procedure, conflict
            detection is stopped for updates and deletes on the specified columns for all apply
            processes at a destination database. To display each column for which conflict
            detection has been stopped, run the following query:</para>

          <screen>COLUMN OBJECT_OWNER HEADING 'Table Owner' FORMAT A15
COLUMN OBJECT_NAME HEADING 'Table Name' FORMAT A20
COLUMN COLUMN_NAME HEADING 'Column Name' FORMAT A20
COLUMN COMPARE_OLD_ON_DELETE HEADING 'Compare|Old On|Delete' FORMAT A7
COLUMN COMPARE_OLD_ON_UPDATE HEADING 'Compare|Old On|Update' FORMAT A7

SELECT OBJECT_OWNER,
       OBJECT_NAME,
       COLUMN_NAME,
       COMPARE_OLD_ON_DELETE,
       COMPARE_OLD_ON_UPDATE
  FROM DBA_APPLY_TABLE_COLUMNS
  WHERE APPLY_DATABASE_LINK IS NULL;</screen>

          <para>Your output should look similar to the following:</para>
          <screen>Compare Compare
                                                          Old On  Old On
Table Owner     Table Name           Column Name          Delete  Update
--------------- -------------------- -------------------- ------- -------
HR              EMPLOYEES            COMMISSION_PCT       NO      NO
HR              EMPLOYEES            EMAIL                NO      NO
HR              EMPLOYEES            FIRST_NAME           NO      NO
HR              EMPLOYEES            HIRE_DATE            NO      NO
HR              EMPLOYEES            JOB_ID               NO      NO
HR              EMPLOYEES            LAST_NAME            NO      NO
HR              EMPLOYEES            PHONE_NUMBER         NO      NO
HR              EMPLOYEES            SALARY               NO      NO</screen>

        </section>

        <section>
          <title>Monitoring Conflict Detection and Update Conflict Handlers</title>

          <para>When you specify an update conflict handler using the
            SET_UPDATE_CONFLICT_HANDLER procedure in the DBMS_APPLY_ADM package, the update
            conflict handler is run for all apply processes in the database, when a relevant
            conflict occurs.</para>

          <para>The query in this section displays all of the columns for which conflict
            resolution has been specified using a prebuilt update conflict handler. That is,
            it shows the columns in all of the column lists specified in the database. This
            query also shows the type of prebuilt conflict handler specified and the resolution
            column specified for the column list.</para>

          <para>To display information about all of the update conflict handlers in a
            database, run the following query:</para>

          <screen>COLUMN OBJECT_OWNER HEADING 'Table|Owner' FORMAT A5
COLUMN OBJECT_NAME HEADING 'Table Name' FORMAT A12
COLUMN METHOD_NAME HEADING 'Method' FORMAT A12
COLUMN RESOLUTION_COLUMN HEADING 'Resolution|Column' FORMAT A13
COLUMN COLUMN_NAME HEADING 'Column Name' FORMAT A30

SELECT OBJECT_OWNER,
       OBJECT_NAME,
       METHOD_NAME,
       RESOLUTION_COLUMN,
       COLUMN_NAME
  FROM DBA_APPLY_CONFLICT_COLUMNS
  ORDER BY OBJECT_OWNER, OBJECT_NAME, RESOLUTION_COLUMN;</screen>

          <para>Your output looks similar to the following:</para>

          <screen>Table                           Resolution
Owner Table Name   Method       Column        Column Name
----- ------------ ------------ ------------- ------------------------------
HR    COUNTRIES    MAXIMUM      TIME          COUNTRY_NAME
HR    COUNTRIES    MAXIMUM      TIME          REGION_ID
HR    COUNTRIES    MAXIMUM      TIME          TIME
HR    DEPARTMENTS  MAXIMUM      TIME          DEPARTMENT_NAME
HR    DEPARTMENTS  MAXIMUM      TIME          LOCATION_ID
HR    DEPARTMENTS  MAXIMUM      TIME          MANAGER_ID
HR    DEPARTMENTS  MAXIMUM      TIME          TIME</screen>
        </section>
      </section>
    </section>

    <section>
      <title>Restart Broken Propagations</title>
      <para>Sometimes, the propagation job for a propagation might become "broken"
        or fail to start after it encounters an error or after a database restart.
        Typically, stopping and restarting the propagation solves the problem. For
        example, to stop and restart a propagation named prop1, run the following
        procedures:</para>
      <screen>$ sqlplus strmadmin/machine4in@dre

BEGIN
  DBMS_PROPAGATION_ADM.STOP_PROPAGATION(
    propagation_name => 'STRMADMIN_PROPAGATE',
    force            => TRUE);
END;
/

BEGIN
  DBMS_PROPAGATION_ADM.START_PROPAGATION(
    propagation_name => 'STRMADMIN_PROPAGATE');
END;
/</screen>
    </section>

    <section>
      <title>Stop Streams</title>
      <screen>
$ sqlplus strmadmin/machine4in@dre
begin
  dbms_capture_adm.stop_capture(
  capture_name => 'STRMADMIN_CAPTURE');
end;
/

$ sqlplus strmadmin/machine4in@dg01
begin
  dbms_apply_adm.stop_apply(
  apply_name => 'STRMADMIN_APPLY');
end;
/</screen>
    </section>

    <section>
      <title>Remove Streams</title>
      <para>After stop Streams, run:</para>
      <screen>
$ sqlplus strmadmin/machine4in@dre
exec DBMS_STREAMS_ADM.remove_streams_configuration();
/

$ sqlplus strmadmin/machine4in@dg01
exec DBMS_STREAMS_ADM.remove_streams_configuration();</screen>
    </section>

    <section>
      <title>Check Streams</title>
      <screen>
$ sqlplus strmadmin/machine4in@dre
SQL> SELECT CAPTURE_NAME, QUEUE_NAME, RULE_SET_NAME, NEGATIVE_RULE_SET_NAME, STATUS FROM DBA_CAPTURE;
STRMADMIN_CAPTURE, STREAMS_QUEUE, RULESET$_57, , ENABLED


SQL> SELECT CAPTURE_NAME, QUEUE_NAME, STATUS, CAPTURED_SCN, APPLIED_SCN FROM DBA_CAPTURE;
STRMADMIN_CAPTURE, STREAMS_QUEUE, ENABLED, 3440980, 3440980

$ sqlplus strmadmin/machine4in@dg01
SQL> SELECT apply_name, apply_captured, status FROM dba_apply;
STRMADMIN_APPLY, YES, ENABLED

SQL> select * from DBA_APPLY_ERROR;</screen>
    </section>

  </section>
</article>

<!--

$ sqlplus dre/dre@dre
SQL> select * from abc order by lastupdate;
insert into abc values('1', '100', 'one', sysdate);
/
insert into abc values('2', '200', 'two', sysdate);
/
insert into abc values('3', '300', 'thi', sysdate);
/
insert into abc values('4', '400', 'fou', sysdate);
/
insert into abc values('5', '500', 'fiv', sysdate);
/
insert into abc values('6', '600', 'six', sysdate);
/
insert into abc values('7', '700', 'sev', sysdate);
/
insert into abc values('8', '800', 'eig', sysdate);
/
commit;

SQL> select count(1) from dre.abc@dg01.songdongsheng.info;
SQL> select count(1) from dre.abc@dre.songdongsheng.info;
-->
